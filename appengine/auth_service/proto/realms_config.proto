// Copyright 2020 The LUCI Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

// Schema for realms.cfg project configuration file.
//
// RealmsCfg describes configuration of all realms of some single LUCI project.


syntax = "proto3";

package auth_service;


// RealmsCfg defines a schema for realms.cfg project configuration file.
message RealmsCfg {
  // List of all realms in the project in arbitrary order.
  repeated Realm realms = 1;

  // Optional list of custom roles that can be referenced from Bindings in this
  // project.
  repeated CustomRole custom_roles = 2;
}


// Realm is a named collection of (<principal>, <permission>) pairs.
//
// A LUCI resource can point to exactly one realm by e.g. specifying its full
// name  ("<project>/<realm>") in `realm` entity field in Datastore (or
// something similar). We say that such resource "belongs to the realm" or
// "lives in the realm". The corresponding Realm message then describes who can
// do what to the resource.
//
// The logic of how resources get assigned to realms is a part of the public API
// of the service that owns resources. Some services may use a static realm
// assignment via project configuration files, others may do it dynamically by
// accepting a realm when a resource is created via an RPC.
//
// The project can have a special realm called "@default". The default realm is
// used to handle a situation when resources refer to realms that no longer
// exist (e.g. they were deleted from realms.cfg). LUCI services fallback to
// checking permissions in the default realm in this case. The default realm
// also act as the root of the realm inheritance tree, i.e. permissions set
// in the default realm are propagates to all other realms in the project.
//
// If the default realm is not defined, it is assumed to be empty.
//
// A realm can "extend" one or more other realms. If a realm `A` extends `B`,
// then all permissions defined in `B` are also in `A`. It is just set
// inclusion.
//
// Finally, the primary way of populating the permission set of a realm is via
// bindings. Each binding assigns a role to a set of principals. Since each role
// is essentially just a set of permissions, each binding adds a Cartesian
// product of s set of permissions (defined via the role) and a set of
// principals (defined via a direct listing or via groups) to the realm.
message Realm {
  // Name of the realm.
  //
  // Should match `^[0-9a-z_\.\-\\]{1,400}$` or be a literal "@default" (to
  // define the default realm of the project).
  string name = 1;

  // Optional list of realms whose permissions will be included in this realm.
  //
  // All realms implicitly extend "@default" realm, i.e. all permissions
  // specified in "@default" realm are propagated to all realms in the project.
  //
  // To keep the mental model simple, cycles aren't allowed (i.e. a realm is not
  // allowed to directly or indirectly extend itself).
  repeated string extends = 2;

  // List of binding that define who can do what to resources in this realm.
  repeated Binding bindings = 3;
}


// Binding assigns a role to all specified principals.
message Binding {
  // Name of the role to assign.
  //
  // Can either be a predefined role (if starts with "role/") or a custom role
  // (if starts with "customRole/"). See TODO for a list of predefined roles
  // and their meanings.
  //
  // A custom role should be defined somewhere in this realms.cfg file.
  string role = 1;

  // A set of principals to assign the role to.
  //
  // Each entry can either be an identity string (like "user:<email>") or a
  // LUCI group reference "group:<name>".
  repeated string principals = 2;
}


// Custom role defines a custom named set of permissions that can be used in
// bindings.
//
// Can be used if predefined roles are too broad or do not map well to the
// desired set of permissions.
message CustomRole {
  // Name of this custom role, must start with "customRole/".
  string name = 1;

  // Optional list of roles whose permissions will be included in this role.
  //
  // Each entry can either be a predefined role (if starts with "role/") or
  // another custom role defined in this file (if starts with "customRole/").
  //
  // To keep the mental model simple, cycles aren't allowed (i.e. a custom role
  // is not allowed to directly or indirectly extend itself).
  repeated string extends = 2;

  // Optional list of permissions to include in the role.
  //
  // Each permission is a symbol that has form "<service>.<subject>.<verb>",
  // which describes some elementary action ("<verb>") that can be done to some
  // category of resources ("<subject>"), managed by some particular kind of
  // LUCI service ("<service>").
  //
  // Examples of permissions:
  //   * buildbucket.build.create
  //   * swarming.pool.listBots
  //   * swarming.task.cancel
  //
  // See TODO for a list of all possible permissions.
  repeated string permissions = 3;
}

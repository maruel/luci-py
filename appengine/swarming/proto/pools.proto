// Copyright 2017 The LUCI Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

syntax = "proto3";


// Schema for pools.cfg service config file in luci-config.
//
// It defined a set of Pool objects, each one corresponding to a single Swarming
// pool dimension. Each Swarming task resided in some pool, and each Swarming
// bot belongs to at least one pool.
//
// Pools are used to isolate groups of tasks/bots from each other for security
// and capacity reasons. Two different pools should not interfere with each
// other at all (unless explicitly configured to share bots or accounts).
message PoolsCfg {
  // List of all defined pools.
  repeated Pool pool = 1;

  // If 'true' and callers try to add a task that use a pool not defined in
  // 'pools' above, Swarming will reject the call with "Permission Denied"
  // error.
  //
  // If 'false', Swarming will allow the task if caller has 'can_create_task'
  // permission. This is used for backward compatibility with simple Swarming
  // deployments that don't do pool isolation.
  //
  // Note that tasks in undefined pools aren't allowed to use service accounts,
  // since Swarming doesn't know what accounts are allowed in such unconfigured
  // pools.
  bool forbid_unknown_pools = 2;

  // This is the "shared namespace" of templates. Swarming will do a 2-pass
  // parse of these so order doesn't matter (i.e. If A includes B, but is
  // defined B-then-A, it's not an error).
  repeated TaskTemplate task_template = 3;

  // This is the "shared namespace" of deployments.
  repeated TaskTemplateDeployment task_template_deployment = 4;
}


// Properties of a single pool or a bunch of identically configured pools.
//
// In particular contains authorization configuration.
message Pool {
  // Names of the pools this config applies to.
  //
  // Tasks target the pool by specifying its name as 'pool' dimension, thus
  // names here should be valid dimension value.
  repeated string name = 1;

  // Contact information for people that own this pool.
  //
  // Not used in any ACLs, just informational field.
  repeated string owners = 2;

  // Defines who can schedule tasks in this pool.
  //
  // The checks here act as a second authorization layer, consulted after the
  // first server-global one (defined based on groups set in settings.cfg, see
  // AuthSettings in config.proto).
  Schedulers schedulers = 3;

  // List of service account emails allowed to be used for tasks that target
  // this pool. Tasks specify the service account via 'service_account' field
  // in the tasks.New RPC.
  //
  // By associating accounts with pools in the config we make it more explicit
  // that a bot belonging to a pool eventually can get access to service
  // accounts of all tasks running in this pool (just by sitting there, grabbing
  // tasks and sniffing service account tokens).
  repeated string allowed_service_account = 4;

  // Same as 'allowed_service_account', but the set of service accounts is
  // specified through an auth group.
  repeated string allowed_service_account_group = 5;

  oneof task_deployment_scheme {
    // Most Pools will include a task_template_deployment by name.
    string task_template_deployment = 6;

    // However, pools which substantially differ from other ones can define an
    // entire deployment inline without putting it in the shared namespace.
    //
    // The name fields in this deployment and any embedded task_templates must
    // not be specified.
    TaskTemplateDeployment task_template_deployment_inline = 7;
  }
}


// Defines who can schedule tasks in a pool.
message Schedulers {
  // Emails of individual end-users.
  //
  // Useful to avoid creating one-person groups.
  repeated string user = 1;

  // List of groups with end-users.
  repeated string group = 2;

  // See TrustedDelegation comment.
  repeated TrustedDelegation trusted_delegation = 3;
}


// Defines a delegatee trusted to make authorization decisions for who can use
// a pool.
//
// This is based on LUCI delegation protocol. Imagine an end user U calling
// Swarming through an intermediary service X. In this case U is a delegator and
// X is a delegatee. When X calls Swarming, it makes an RPC to the token server
// to make a delegation token that says "<X can call Swarming on behalf of U>".
//
// This token is then sent to the Swarming with the RPC. Swarming sees that
// the direct peer it's talking to is X, but the call should be performed under
// the authority of U.
//
// We extend this to also allow X make authorization decisions about whether U
// can use particular Swarming resource or not. The result of this decision is
// encoded in the delegation token as a set of "key:value" tags. Swarming then
// can treat presence of such tags as a signal that the particular call is
// allowed.
//
// In this scenario we totally trust X to make the correct decision.
message TrustedDelegation {
  message TagList {
    repeated string tag = 1;
  }

  // Email of a trusted delegatee (the one who's minting the delegation token).
  string peer_id = 1;

  // A list of tags to expected in the delegation token to allow the usage of
  // a pool.
  //
  // Presence of any of the specified tags are enough. The format of these tags
  // generally depends on what service is doing the delegation.
  TagList require_any_of = 2;
}

message TaskTemplate {
  // This gives the template a name for the 'include' field below. This only
  // applies to templates defined within the PoolsCfg message (i.e. the
  // top-level message), not to templates inlined into a TaskTemplateDeployment.
  string name = 1;

  // Includes properties from the named other TaskTemplate. This can only
  // include templates defined in the top-level PoolsCfg message.
  repeated string include = 2;

  message CacheEntry {
    string name = 1;
    // A path of "" is not permitted.
    string path = 2;
  }
  // Inclusions override cache entries by the name field. It is illegal to have
  // any TaskTemplate with multiple cache entries mapping to the same path. It
  // is illegal to have any cache paths overlap with cipd package paths.
  repeated CacheEntry cache = 3;

  message CipdPackage {
    string path = 1;
    string pkg = 2;
    // A version of "" is not permitted.
    string version = 3;
  }
  // Inclusions override cipd packages by (path, name).
  //
  // It is illegal to have any cipd paths overlap with cache entry paths.
  repeated CipdPackage cipd_package = 4;

  message Env {
    // The actual envvar you want to set.
    string var = 1;

    // A value of "" is not permitted.
    string value = 2;

    // Values of "" are not permitted.
    repeated string prefix = 3;

    // If true, tasks setting this EnvVar can overwrite the value and/or the
    // prefix. Otherwise, tasks will not be permitted to to set an env var or
    // env_prefix for this var.
    bool soft = 4;
  }
  // Inclusions override by the `var` field.
  //
  // `value` fields overwrite included values.
  // `prefix` fields append to included values.
  // `soft` fields overwrite included values.
  repeated Env env = 5;
}

// This is a tuple of (prod template, canary template, canary_chance), so that it
// can be referenced from multiple pools simultaneously as a single unit.
message TaskTemplateDeployment {
  // This gives the deployment a name for the 'task_template_deployment' field
  // in PoolCfg.
  //
  // When this TaskTemplateDeployment is inlined into another message (e.g.
  // `TaskTemplate.task_template_deployment_inline`), the name field must not be
  // specified.
  string name = 1;

  // Most Deployments will have a TaskTemplate with just a single include
  // directive.
  //
  // However, pools which substantially differ from other ones could define an
  // entire template inline without being forced to put it in the shared
  // namespace.
  //
  // The name field in this template (and the canary template) must not be
  // specified.
  TaskTemplate prod = 2;

  TaskTemplate canary = 3;

  // range [0, 1.0). Exactly 0 means 'canary is disabled', meaning that tasks
  // in this pool will always get the prod template.
  //
  // Examples:
  //   * 0.1   "10% chance of picking canary"
  //   * 0.5   "50% chance of picking canary"
  //   * 0.75  "75% chance of picking canary"
  double canary_chance = 4;
}

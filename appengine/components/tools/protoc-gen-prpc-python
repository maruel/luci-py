#!/usr/bin/env python
# Copyright 2017 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

import base64
import sys

from google.protobuf import descriptor_pb2
from google.protobuf.compiler import plugin_pb2 as plugin


HEADER_FORMAT = '''
# Generated by the pRPC protocol buffer compiler plugin.  DO NOT EDIT!
# source: %(file_name)s

import base64

from google.protobuf import descriptor_pb2

# Includes description of the %(file_name)s and all of its transitive
# dependencies. Includes source code info.
FILE_DESCRIPTOR_SET = descriptor_pb2.FileDescriptorSet()
FILE_DESCRIPTOR_SET.ParseFromString(base64.b64decode(
%(file_set_descriptor_b64)s))
'''


SERVICE_FORMAT = '''
%(service_name)sServiceDescription = {
  'file_descriptor_set': FILE_DESCRIPTOR_SET,
  'file_name': '%(file_name)s',
  'service_name': '%(service_name)s',
}
'''


def build_file_set_descriptor(root_name, files):
  added = set()
  ret = descriptor_pb2.FileDescriptorSet()

  def ensure_file(name):
    if name in added:
      return

    file = files[name]
    added.add(name)
    ret.file.add().CopyFrom(file)
    for dep in file.dependency:
      ensure_file(dep)

  ensure_file(root_name)
  return ret


def string_to_code_lines(string_literal, indent=0):
  """Generates multiline Python string literal."""
  ret = []
  max_string_line_len = 80 - 2 - indent
  i = 0
  indent_str = ' ' * indent
  while i < len(string_literal):
    chunk = string_literal[i:i+max_string_line_len]
    i += max_string_line_len
    ret.append('%s%r' % (indent_str, chunk))
  return '\n'.join(ret)


def generate_code(file_descriptor, all_files):
  file_set = build_file_set_descriptor(file_descriptor.name, all_files)
  fragments = [HEADER_FORMAT % {
      'file_name': file_descriptor.name,
      'file_set_descriptor_b64': string_to_code_lines(
          base64.b64encode(file_set.SerializeToString()),
          indent=4),
  }]

  for service in file_descriptor.service:
    fragments.append(SERVICE_FORMAT % {
        'file_name': file_descriptor.name,
        'service_name': service.name,
    })
  return ('\n'.join(fragments)).strip() + '\n'


def main():
  data = sys.stdin.read()
  req = plugin.CodeGeneratorRequest()
  req.ParseFromString(data)
  res = plugin.CodeGeneratorResponse()
  files_to_generate = set(req.file_to_generate)
  files = {f.name: f for f in req.proto_file}
  for input in req.proto_file:
    if input.name not in files_to_generate or not input.service:
      continue
    res.file.add(
        name=input.name.replace('.proto', '_prpc_pb2.py'),
        content=generate_code(input, files),
    )
  sys.stdout.write(res.SerializeToString())


if __name__ == '__main__':
   main()
